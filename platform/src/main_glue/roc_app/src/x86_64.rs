// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

#[derive(Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Header {
    f0: roc_std::RocStr,
    f1: roc_std::RocStr,
}

impl Header {
    /// A tag named ``Header``, with the given payload.
    pub fn Header(f0: roc_std::RocStr, f1: roc_std::RocStr) -> Self {
        Self { f0, f1 }
    }

    /// Since `Header` only has one tag (namely, `Header`),
    /// convert it to `Header`'s payload.
    pub fn into_Header(self) -> (roc_std::RocStr, roc_std::RocStr) {
        (self.f0, self.f1)
    }

    /// Since `Header` only has one tag (namely, `Header`),
    /// convert it to `Header`'s payload.
    pub fn as_Header(&self) -> (&roc_std::RocStr, &roc_std::RocStr) {
        (&self.f0, &self.f1)
    }
}

impl core::fmt::Debug for Header {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("Header::Header")
            .field(&self.f0)
            .field(&self.f1)
            .finish()
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_TimeoutConfig {
    NoTimeout = 0,
    TimeoutMilliseconds = 1,
}

impl core::fmt::Debug for discriminant_TimeoutConfig {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::NoTimeout => f.write_str("discriminant_TimeoutConfig::NoTimeout"),
            Self::TimeoutMilliseconds => {
                f.write_str("discriminant_TimeoutConfig::TimeoutMilliseconds")
            }
        }
    }
}

#[repr(C, align(8))]
pub union union_TimeoutConfig {
    NoTimeout: (),
    TimeoutMilliseconds: u64,
}

const _SIZE_CHECK_union_TimeoutConfig: () =
    assert!(core::mem::size_of::<union_TimeoutConfig>() == 8);
const _ALIGN_CHECK_union_TimeoutConfig: () =
    assert!(core::mem::align_of::<union_TimeoutConfig>() == 8);

const _SIZE_CHECK_TimeoutConfig: () = assert!(core::mem::size_of::<TimeoutConfig>() == 16);
const _ALIGN_CHECK_TimeoutConfig: () = assert!(core::mem::align_of::<TimeoutConfig>() == 8);

impl TimeoutConfig {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_TimeoutConfig {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_TimeoutConfig>(*bytes.as_ptr().add(8))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_TimeoutConfig) {
        let discriminant_ptr: *mut discriminant_TimeoutConfig = (self as *mut TimeoutConfig).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct TimeoutConfig {
    payload: union_TimeoutConfig,
    discriminant: discriminant_TimeoutConfig,
}

impl Clone for TimeoutConfig {
    fn clone(&self) -> Self {
        use discriminant_TimeoutConfig::*;

        let payload = unsafe {
            match self.discriminant {
                NoTimeout => union_TimeoutConfig {
                    NoTimeout: self.payload.NoTimeout.clone(),
                },
                TimeoutMilliseconds => union_TimeoutConfig {
                    TimeoutMilliseconds: self.payload.TimeoutMilliseconds.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for TimeoutConfig {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_TimeoutConfig::*;

        unsafe {
            match self.discriminant {
                NoTimeout => {
                    let field: &() = &self.payload.NoTimeout;
                    f.debug_tuple("TimeoutConfig::NoTimeout")
                        .field(field)
                        .finish()
                }
                TimeoutMilliseconds => {
                    let field: &u64 = &self.payload.TimeoutMilliseconds;
                    f.debug_tuple("TimeoutConfig::TimeoutMilliseconds")
                        .field(field)
                        .finish()
                }
            }
        }
    }
}

impl Eq for TimeoutConfig {}

impl PartialEq for TimeoutConfig {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_TimeoutConfig::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                NoTimeout => self.payload.NoTimeout == other.payload.NoTimeout,
                TimeoutMilliseconds => {
                    self.payload.TimeoutMilliseconds == other.payload.TimeoutMilliseconds
                }
            }
        }
    }
}

impl Ord for TimeoutConfig {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for TimeoutConfig {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_TimeoutConfig::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    NoTimeout => self.payload.NoTimeout.partial_cmp(&other.payload.NoTimeout),
                    TimeoutMilliseconds => self
                        .payload
                        .TimeoutMilliseconds
                        .partial_cmp(&other.payload.TimeoutMilliseconds),
                }
            },
        }
    }
}

impl core::hash::Hash for TimeoutConfig {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_TimeoutConfig::*;

        unsafe {
            match self.discriminant {
                NoTimeout => self.payload.NoTimeout.hash(state),
                TimeoutMilliseconds => self.payload.TimeoutMilliseconds.hash(state),
            }
        }
    }
}

impl TimeoutConfig {
    pub fn is_NoTimeout(&self) -> bool {
        matches!(self.discriminant, discriminant_TimeoutConfig::NoTimeout)
    }

    pub fn unwrap_TimeoutMilliseconds(mut self) -> u64 {
        debug_assert_eq!(
            self.discriminant,
            discriminant_TimeoutConfig::TimeoutMilliseconds
        );
        unsafe { self.payload.TimeoutMilliseconds }
    }

    pub fn is_TimeoutMilliseconds(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_TimeoutConfig::TimeoutMilliseconds
        )
    }
}

impl TimeoutConfig {
    pub fn NoTimeout() -> Self {
        Self {
            discriminant: discriminant_TimeoutConfig::NoTimeout,
            payload: union_TimeoutConfig { NoTimeout: () },
        }
    }

    pub fn TimeoutMilliseconds(payload: u64) -> Self {
        Self {
            discriminant: discriminant_TimeoutConfig::TimeoutMilliseconds,
            payload: union_TimeoutConfig {
                TimeoutMilliseconds: payload,
            },
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum Method {
    Connect = 0,
    Delete = 1,
    Get = 2,
    Head = 3,
    Options = 4,
    Patch = 5,
    Post = 6,
    Put = 7,
    Trace = 8,
}

impl core::fmt::Debug for Method {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Connect => f.write_str("Method::Connect"),
            Self::Delete => f.write_str("Method::Delete"),
            Self::Get => f.write_str("Method::Get"),
            Self::Head => f.write_str("Method::Head"),
            Self::Options => f.write_str("Method::Options"),
            Self::Patch => f.write_str("Method::Patch"),
            Self::Post => f.write_str("Method::Post"),
            Self::Put => f.write_str("Method::Put"),
            Self::Trace => f.write_str("Method::Trace"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Request {
    pub body: roc_std::RocList<u8>,
    pub headers: roc_std::RocList<Header>,
    pub mimeType: roc_std::RocStr,
    pub timeout: TimeoutConfig,
    pub url: roc_std::RocStr,
    pub method: Method,
}

#[derive(Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Part {
    f0: roc_std::RocStr,
    f1: roc_std::RocList<u8>,
}

impl Part {
    /// A tag named ``Part``, with the given payload.
    pub fn Part(f0: roc_std::RocStr, f1: roc_std::RocList<u8>) -> Self {
        Self { f0, f1 }
    }

    /// Since `Part` only has one tag (namely, `Part`),
    /// convert it to `Part`'s payload.
    pub fn into_Part(self) -> (roc_std::RocStr, roc_std::RocList<u8>) {
        (self.f0, self.f1)
    }

    /// Since `Part` only has one tag (namely, `Part`),
    /// convert it to `Part`'s payload.
    pub fn as_Part(&self) -> (&roc_std::RocStr, &roc_std::RocList<u8>) {
        (&self.f0, &self.f1)
    }
}

impl core::fmt::Debug for Part {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("Part::Part")
            .field(&self.f0)
            .field(&self.f1)
            .finish()
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Metadata {
    pub headers: roc_std::RocList<Header>,
    pub statusText: roc_std::RocStr,
    pub url: roc_std::RocStr,
    pub statusCode: u16,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Response_BadStatus {
    pub f0: Metadata,
    pub f1: roc_std::RocList<u8>,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_Response {
    BadRequest = 0,
    BadStatus = 1,
    GoodStatus = 2,
    NetworkError = 3,
    Timeout = 4,
}

impl core::fmt::Debug for discriminant_Response {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BadRequest => f.write_str("discriminant_Response::BadRequest"),
            Self::BadStatus => f.write_str("discriminant_Response::BadStatus"),
            Self::GoodStatus => f.write_str("discriminant_Response::GoodStatus"),
            Self::NetworkError => f.write_str("discriminant_Response::NetworkError"),
            Self::Timeout => f.write_str("discriminant_Response::Timeout"),
        }
    }
}

#[repr(C, align(8))]
pub union union_Response {
    BadRequest: core::mem::ManuallyDrop<roc_std::RocStr>,
    BadStatus: core::mem::ManuallyDrop<Response_BadStatus>,
    GoodStatus: core::mem::ManuallyDrop<Response_BadStatus>,
    NetworkError: (),
    Timeout: u64,
}

// const _SIZE_CHECK_union_Response: () = assert!(core::mem::size_of::<union_Response>() == 112);
const _ALIGN_CHECK_union_Response: () = assert!(core::mem::align_of::<union_Response>() == 8);

const _SIZE_CHECK_Response: () = assert!(core::mem::size_of::<Response>() == 112);
const _ALIGN_CHECK_Response: () = assert!(core::mem::align_of::<Response>() == 8);

impl Response {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Response {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Response>(*bytes.as_ptr().add(104))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Response) {
        let discriminant_ptr: *mut discriminant_Response = (self as *mut Response).cast();

        unsafe {
            *(discriminant_ptr.add(104)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Response {
    payload: union_Response,
    discriminant: discriminant_Response,
}

impl Clone for Response {
    fn clone(&self) -> Self {
        use discriminant_Response::*;

        let payload = unsafe {
            match self.discriminant {
                BadRequest => union_Response {
                    BadRequest: self.payload.BadRequest.clone(),
                },
                BadStatus => union_Response {
                    BadStatus: self.payload.BadStatus.clone(),
                },
                GoodStatus => union_Response {
                    GoodStatus: self.payload.GoodStatus.clone(),
                },
                NetworkError => union_Response {
                    NetworkError: self.payload.NetworkError.clone(),
                },
                Timeout => union_Response {
                    Timeout: self.payload.Timeout.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Response {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Response::*;

        unsafe {
            match self.discriminant {
                BadRequest => {
                    let field: &roc_std::RocStr = &self.payload.BadRequest;
                    f.debug_tuple("Response::BadRequest").field(field).finish()
                }
                BadStatus => {
                    let field: &Response_BadStatus = &self.payload.BadStatus;
                    f.debug_tuple("Response::BadStatus").field(field).finish()
                }
                GoodStatus => {
                    let field: &Response_BadStatus = &self.payload.GoodStatus;
                    f.debug_tuple("Response::GoodStatus").field(field).finish()
                }
                NetworkError => {
                    let field: &() = &self.payload.NetworkError;
                    f.debug_tuple("Response::NetworkError")
                        .field(field)
                        .finish()
                }
                Timeout => {
                    let field: &u64 = &self.payload.Timeout;
                    f.debug_tuple("Response::Timeout").field(field).finish()
                }
            }
        }
    }
}

impl Eq for Response {}

impl PartialEq for Response {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Response::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                BadRequest => self.payload.BadRequest == other.payload.BadRequest,
                BadStatus => self.payload.BadStatus == other.payload.BadStatus,
                GoodStatus => self.payload.GoodStatus == other.payload.GoodStatus,
                NetworkError => self.payload.NetworkError == other.payload.NetworkError,
                Timeout => self.payload.Timeout == other.payload.Timeout,
            }
        }
    }
}

impl Ord for Response {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Response {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Response::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    BadRequest => self
                        .payload
                        .BadRequest
                        .partial_cmp(&other.payload.BadRequest),
                    BadStatus => self.payload.BadStatus.partial_cmp(&other.payload.BadStatus),
                    GoodStatus => self
                        .payload
                        .GoodStatus
                        .partial_cmp(&other.payload.GoodStatus),
                    NetworkError => self
                        .payload
                        .NetworkError
                        .partial_cmp(&other.payload.NetworkError),
                    Timeout => self.payload.Timeout.partial_cmp(&other.payload.Timeout),
                }
            },
        }
    }
}

impl core::hash::Hash for Response {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Response::*;

        unsafe {
            match self.discriminant {
                BadRequest => self.payload.BadRequest.hash(state),
                BadStatus => self.payload.BadStatus.hash(state),
                GoodStatus => self.payload.GoodStatus.hash(state),
                NetworkError => self.payload.NetworkError.hash(state),
                Timeout => self.payload.Timeout.hash(state),
            }
        }
    }
}

impl Response {
    pub fn unwrap_BadRequest(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Response::BadRequest);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.BadRequest) }
    }

    pub fn is_BadRequest(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::BadRequest)
    }

    pub fn unwrap_BadStatus(mut self) -> Response_BadStatus {
        debug_assert_eq!(self.discriminant, discriminant_Response::BadStatus);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.BadStatus) }
    }

    pub fn is_BadStatus(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::BadStatus)
    }

    pub fn unwrap_GoodStatus(mut self) -> Response_BadStatus {
        debug_assert_eq!(self.discriminant, discriminant_Response::GoodStatus);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.GoodStatus) }
    }

    pub fn is_GoodStatus(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::GoodStatus)
    }

    pub fn is_NetworkError(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::NetworkError)
    }

    pub fn unwrap_Timeout(mut self) -> u64 {
        debug_assert_eq!(self.discriminant, discriminant_Response::Timeout);
        unsafe { self.payload.Timeout }
    }

    pub fn is_Timeout(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::Timeout)
    }
}

impl Response {
    pub fn BadRequest(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Response::BadRequest,
            payload: union_Response {
                BadRequest: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn BadStatus(payload: Response_BadStatus) -> Self {
        Self {
            discriminant: discriminant_Response::BadStatus,
            payload: union_Response {
                BadStatus: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn GoodStatus(payload: Response_BadStatus) -> Self {
        Self {
            discriminant: discriminant_Response::GoodStatus,
            payload: union_Response {
                GoodStatus: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn NetworkError() -> Self {
        Self {
            discriminant: discriminant_Response::NetworkError,
            payload: union_Response { NetworkError: () },
        }
    }

    pub fn Timeout(payload: u64) -> Self {
        Self {
            discriminant: discriminant_Response::Timeout,
            payload: union_Response { Timeout: payload },
        }
    }
}

impl Drop for Response {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Response::BadRequest => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.BadRequest)
            },
            discriminant_Response::BadStatus => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.BadStatus)
            },
            discriminant_Response::GoodStatus => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.GoodStatus)
            },
            discriminant_Response::NetworkError => {}
            discriminant_Response::Timeout => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_Error {
    BadBody = 0,
    BadRequest = 1,
    BadStatus = 2,
    NetworkError = 3,
    Timeout = 4,
}

impl core::fmt::Debug for discriminant_Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BadBody => f.write_str("discriminant_Error::BadBody"),
            Self::BadRequest => f.write_str("discriminant_Error::BadRequest"),
            Self::BadStatus => f.write_str("discriminant_Error::BadStatus"),
            Self::NetworkError => f.write_str("discriminant_Error::NetworkError"),
            Self::Timeout => f.write_str("discriminant_Error::Timeout"),
        }
    }
}

#[repr(C, align(8))]
pub union union_Error {
    BadBody: core::mem::ManuallyDrop<roc_std::RocStr>,
    BadRequest: core::mem::ManuallyDrop<roc_std::RocStr>,
    BadStatus: u16,
    NetworkError: (),
    Timeout: u64,
}

const _SIZE_CHECK_union_Error: () = assert!(core::mem::size_of::<union_Error>() == 24);
const _ALIGN_CHECK_union_Error: () = assert!(core::mem::align_of::<union_Error>() == 8);

const _SIZE_CHECK_Error: () = assert!(core::mem::size_of::<Error>() == 32);
const _ALIGN_CHECK_Error: () = assert!(core::mem::align_of::<Error>() == 8);

impl Error {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Error {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Error>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Error) {
        let discriminant_ptr: *mut discriminant_Error = (self as *mut Error).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Error {
    payload: union_Error,
    discriminant: discriminant_Error,
}

impl Clone for Error {
    fn clone(&self) -> Self {
        use discriminant_Error::*;

        let payload = unsafe {
            match self.discriminant {
                BadBody => union_Error {
                    BadBody: self.payload.BadBody.clone(),
                },
                BadRequest => union_Error {
                    BadRequest: self.payload.BadRequest.clone(),
                },
                BadStatus => union_Error {
                    BadStatus: self.payload.BadStatus.clone(),
                },
                NetworkError => union_Error {
                    NetworkError: self.payload.NetworkError.clone(),
                },
                Timeout => union_Error {
                    Timeout: self.payload.Timeout.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Error::*;

        unsafe {
            match self.discriminant {
                BadBody => {
                    let field: &roc_std::RocStr = &self.payload.BadBody;
                    f.debug_tuple("Error::BadBody").field(field).finish()
                }
                BadRequest => {
                    let field: &roc_std::RocStr = &self.payload.BadRequest;
                    f.debug_tuple("Error::BadRequest").field(field).finish()
                }
                BadStatus => {
                    let field: &u16 = &self.payload.BadStatus;
                    f.debug_tuple("Error::BadStatus").field(field).finish()
                }
                NetworkError => {
                    let field: &() = &self.payload.NetworkError;
                    f.debug_tuple("Error::NetworkError").field(field).finish()
                }
                Timeout => {
                    let field: &u64 = &self.payload.Timeout;
                    f.debug_tuple("Error::Timeout").field(field).finish()
                }
            }
        }
    }
}

impl Eq for Error {}

impl PartialEq for Error {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Error::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                BadBody => self.payload.BadBody == other.payload.BadBody,
                BadRequest => self.payload.BadRequest == other.payload.BadRequest,
                BadStatus => self.payload.BadStatus == other.payload.BadStatus,
                NetworkError => self.payload.NetworkError == other.payload.NetworkError,
                Timeout => self.payload.Timeout == other.payload.Timeout,
            }
        }
    }
}

impl Ord for Error {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Error {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Error::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    BadBody => self.payload.BadBody.partial_cmp(&other.payload.BadBody),
                    BadRequest => self
                        .payload
                        .BadRequest
                        .partial_cmp(&other.payload.BadRequest),
                    BadStatus => self.payload.BadStatus.partial_cmp(&other.payload.BadStatus),
                    NetworkError => self
                        .payload
                        .NetworkError
                        .partial_cmp(&other.payload.NetworkError),
                    Timeout => self.payload.Timeout.partial_cmp(&other.payload.Timeout),
                }
            },
        }
    }
}

impl core::hash::Hash for Error {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Error::*;

        unsafe {
            match self.discriminant {
                BadBody => self.payload.BadBody.hash(state),
                BadRequest => self.payload.BadRequest.hash(state),
                BadStatus => self.payload.BadStatus.hash(state),
                NetworkError => self.payload.NetworkError.hash(state),
                Timeout => self.payload.Timeout.hash(state),
            }
        }
    }
}

impl Error {
    pub fn unwrap_BadBody(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Error::BadBody);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.BadBody) }
    }

    pub fn is_BadBody(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::BadBody)
    }

    pub fn unwrap_BadRequest(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Error::BadRequest);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.BadRequest) }
    }

    pub fn is_BadRequest(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::BadRequest)
    }

    pub fn unwrap_BadStatus(mut self) -> u16 {
        debug_assert_eq!(self.discriminant, discriminant_Error::BadStatus);
        unsafe { self.payload.BadStatus }
    }

    pub fn is_BadStatus(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::BadStatus)
    }

    pub fn is_NetworkError(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::NetworkError)
    }

    pub fn unwrap_Timeout(mut self) -> u64 {
        debug_assert_eq!(self.discriminant, discriminant_Error::Timeout);
        unsafe { self.payload.Timeout }
    }

    pub fn is_Timeout(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::Timeout)
    }
}

impl Error {
    pub fn BadBody(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Error::BadBody,
            payload: union_Error {
                BadBody: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn BadRequest(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Error::BadRequest,
            payload: union_Error {
                BadRequest: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn BadStatus(payload: u16) -> Self {
        Self {
            discriminant: discriminant_Error::BadStatus,
            payload: union_Error { BadStatus: payload },
        }
    }

    pub fn NetworkError() -> Self {
        Self {
            discriminant: discriminant_Error::NetworkError,
            payload: union_Error { NetworkError: () },
        }
    }

    pub fn Timeout(payload: u64) -> Self {
        Self {
            discriminant: discriminant_Error::Timeout,
            payload: union_Error { Timeout: payload },
        }
    }
}

impl Drop for Error {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Error::BadBody => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.BadBody)
            },
            discriminant_Error::BadRequest => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.BadRequest)
            },
            discriminant_Error::BadStatus => {}
            discriminant_Error::NetworkError => {}
            discriminant_Error::Timeout => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_GlueTypes {
    A = 0,
    B = 1,
    C = 2,
    D = 3,
    E = 4,
    G = 5,
    H = 6,
    I = 7,
}

impl core::fmt::Debug for discriminant_GlueTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::A => f.write_str("discriminant_GlueTypes::A"),
            Self::B => f.write_str("discriminant_GlueTypes::B"),
            Self::C => f.write_str("discriminant_GlueTypes::C"),
            Self::D => f.write_str("discriminant_GlueTypes::D"),
            Self::E => f.write_str("discriminant_GlueTypes::E"),
            Self::G => f.write_str("discriminant_GlueTypes::G"),
            Self::H => f.write_str("discriminant_GlueTypes::H"),
            Self::I => f.write_str("discriminant_GlueTypes::I"),
        }
    }
}

#[repr(C, align(8))]
pub union union_GlueTypes {
    A: core::mem::ManuallyDrop<Request>,
    B: Method,
    C: core::mem::ManuallyDrop<Header>,
    D: core::mem::ManuallyDrop<TimeoutConfig>,
    E: core::mem::ManuallyDrop<Part>,
    G: core::mem::ManuallyDrop<Response>,
    H: core::mem::ManuallyDrop<Metadata>,
    I: core::mem::ManuallyDrop<Error>,
}

const _SIZE_CHECK_union_GlueTypes: () = assert!(core::mem::size_of::<union_GlueTypes>() == 120);
const _ALIGN_CHECK_union_GlueTypes: () = assert!(core::mem::align_of::<union_GlueTypes>() == 8);

const _SIZE_CHECK_GlueTypes: () = assert!(core::mem::size_of::<GlueTypes>() == 128);
const _ALIGN_CHECK_GlueTypes: () = assert!(core::mem::align_of::<GlueTypes>() == 8);

impl GlueTypes {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_GlueTypes {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_GlueTypes>(*bytes.as_ptr().add(120))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_GlueTypes) {
        let discriminant_ptr: *mut discriminant_GlueTypes = (self as *mut GlueTypes).cast();

        unsafe {
            *(discriminant_ptr.add(120)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct GlueTypes {
    payload: union_GlueTypes,
    discriminant: discriminant_GlueTypes,
}

impl Clone for GlueTypes {
    fn clone(&self) -> Self {
        use discriminant_GlueTypes::*;

        let payload = unsafe {
            match self.discriminant {
                A => union_GlueTypes {
                    A: self.payload.A.clone(),
                },
                B => union_GlueTypes {
                    B: self.payload.B.clone(),
                },
                C => union_GlueTypes {
                    C: self.payload.C.clone(),
                },
                D => union_GlueTypes {
                    D: self.payload.D.clone(),
                },
                E => union_GlueTypes {
                    E: self.payload.E.clone(),
                },
                G => union_GlueTypes {
                    G: self.payload.G.clone(),
                },
                H => union_GlueTypes {
                    H: self.payload.H.clone(),
                },
                I => union_GlueTypes {
                    I: self.payload.I.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for GlueTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_GlueTypes::*;

        unsafe {
            match self.discriminant {
                A => {
                    let field: &Request = &self.payload.A;
                    f.debug_tuple("GlueTypes::A").field(field).finish()
                }
                B => {
                    let field: &Method = &self.payload.B;
                    f.debug_tuple("GlueTypes::B").field(field).finish()
                }
                C => {
                    let field: &Header = &self.payload.C;
                    f.debug_tuple("GlueTypes::C").field(field).finish()
                }
                D => {
                    let field: &TimeoutConfig = &self.payload.D;
                    f.debug_tuple("GlueTypes::D").field(field).finish()
                }
                E => {
                    let field: &Part = &self.payload.E;
                    f.debug_tuple("GlueTypes::E").field(field).finish()
                }
                G => {
                    let field: &Response = &self.payload.G;
                    f.debug_tuple("GlueTypes::G").field(field).finish()
                }
                H => {
                    let field: &Metadata = &self.payload.H;
                    f.debug_tuple("GlueTypes::H").field(field).finish()
                }
                I => {
                    let field: &Error = &self.payload.I;
                    f.debug_tuple("GlueTypes::I").field(field).finish()
                }
            }
        }
    }
}

impl Eq for GlueTypes {}

impl PartialEq for GlueTypes {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_GlueTypes::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                A => self.payload.A == other.payload.A,
                B => self.payload.B == other.payload.B,
                C => self.payload.C == other.payload.C,
                D => self.payload.D == other.payload.D,
                E => self.payload.E == other.payload.E,
                G => self.payload.G == other.payload.G,
                H => self.payload.H == other.payload.H,
                I => self.payload.I == other.payload.I,
            }
        }
    }
}

impl Ord for GlueTypes {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for GlueTypes {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_GlueTypes::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    A => self.payload.A.partial_cmp(&other.payload.A),
                    B => self.payload.B.partial_cmp(&other.payload.B),
                    C => self.payload.C.partial_cmp(&other.payload.C),
                    D => self.payload.D.partial_cmp(&other.payload.D),
                    E => self.payload.E.partial_cmp(&other.payload.E),
                    G => self.payload.G.partial_cmp(&other.payload.G),
                    H => self.payload.H.partial_cmp(&other.payload.H),
                    I => self.payload.I.partial_cmp(&other.payload.I),
                }
            },
        }
    }
}

impl core::hash::Hash for GlueTypes {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_GlueTypes::*;

        unsafe {
            match self.discriminant {
                A => self.payload.A.hash(state),
                B => self.payload.B.hash(state),
                C => self.payload.C.hash(state),
                D => self.payload.D.hash(state),
                E => self.payload.E.hash(state),
                G => self.payload.G.hash(state),
                H => self.payload.H.hash(state),
                I => self.payload.I.hash(state),
            }
        }
    }
}

impl GlueTypes {
    pub fn unwrap_A(mut self) -> Request {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::A);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.A) }
    }

    pub fn is_A(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::A)
    }

    pub fn unwrap_B(mut self) -> Method {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::B);
        unsafe { self.payload.B }
    }

    pub fn is_B(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::B)
    }

    pub fn unwrap_C(mut self) -> Header {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::C);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.C) }
    }

    pub fn is_C(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::C)
    }

    pub fn unwrap_D(mut self) -> TimeoutConfig {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::D);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.D) }
    }

    pub fn is_D(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::D)
    }

    pub fn unwrap_E(mut self) -> Part {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::E);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.E) }
    }

    pub fn is_E(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::E)
    }

    pub fn unwrap_G(mut self) -> Response {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::G);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.G) }
    }

    pub fn is_G(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::G)
    }

    pub fn unwrap_H(mut self) -> Metadata {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::H);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.H) }
    }

    pub fn is_H(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::H)
    }

    pub fn unwrap_I(mut self) -> Error {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::I);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.I) }
    }

    pub fn is_I(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::I)
    }
}

impl GlueTypes {
    pub fn A(payload: Request) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::A,
            payload: union_GlueTypes {
                A: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn B(payload: Method) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::B,
            payload: union_GlueTypes { B: payload },
        }
    }

    pub fn C(payload: Header) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::C,
            payload: union_GlueTypes {
                C: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn D(payload: TimeoutConfig) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::D,
            payload: union_GlueTypes {
                D: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn E(payload: Part) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::E,
            payload: union_GlueTypes {
                E: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn G(payload: Response) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::G,
            payload: union_GlueTypes {
                G: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn H(payload: Metadata) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::H,
            payload: union_GlueTypes {
                H: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn I(payload: Error) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::I,
            payload: union_GlueTypes {
                I: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for GlueTypes {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_GlueTypes::A => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.A)
            },
            discriminant_GlueTypes::B => {}
            discriminant_GlueTypes::C => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.C)
            },
            discriminant_GlueTypes::D => {}
            discriminant_GlueTypes::E => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.E)
            },
            discriminant_GlueTypes::G => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.G)
            },
            discriminant_GlueTypes::H => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.H)
            },
            discriminant_GlueTypes::I => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.I)
            },
        }
    }
}

pub fn mainForHost() -> GlueTypes {
    #[allow(improper_ctypes)]
    extern "C" {
        fn roc__mainForHost_1_exposed_generic(_: *mut GlueTypes);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__mainForHost_1_exposed_generic(ret.as_mut_ptr());

        ret.assume_init()
    }
}
